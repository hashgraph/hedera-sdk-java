package com.hedera.sdk.crypto.ed25519;

import org.bouncycastle.math.ec.rfc8032.Ed25519;
import org.bouncycastle.util.encoders.Hex;

/** ED25519 signature generation and verification */
public final class Ed25519Signature {
    private final byte[] sigBytes;

    private Ed25519Signature(byte[] sigBytes) {
        this.sigBytes = sigBytes;
    }

    /** Recover a signature from its binary representation given by {@link #toBytes()} */
    public static Ed25519Signature fromBytes(byte[] signature) {
        assert signature.length == Ed25519.SIGNATURE_SIZE;
        return new Ed25519Signature(signature);
    }

    /** Recover a signature from its text representation given by {@link #toString()} */
    public static Ed25519Signature fromString(String sigString) {
        return fromBytes(Hex.decode(sigString));
    }

    /** Calculate an ED25519 signature from the given private key and message bytes. */
    public static Ed25519Signature forMessage(Ed25519PrivateKey privateKey, byte[] message) {
        return forMessage(privateKey, message, 0, message.length);
    }

    /**
     * Calculate an ED25519 signature from the given private key and message bytes (with offset into
     * the byte array and number of bytes to process).
     */
    public static Ed25519Signature forMessage(
            Ed25519PrivateKey privateKey, byte[] message, int messageOffset, int messageLen) {
        // we don't use the `Ed25519Signer` class because it unnecessarily calculates the public key
        // in `init()`
        var secret = privateKey.toBytes();
        var sigBytes = new byte[Ed25519.SIGNATURE_SIZE];
        Ed25519.sign(secret, 0, message, messageOffset, messageLen, sigBytes, 0);
        return new Ed25519Signature(sigBytes);
    }

    /**
     * Verify that this signature was generated by the owner of the given public key, for the given
     * message bytes.
     */
    public boolean verify(Ed25519PublicKey publicKey, byte[] message) {
        return verify(publicKey, message, 0, message.length);
    }

    /**
     * Verify that this signature was generated by the owner of the given public key, for the given
     * message bytes (with offset into the byte array and number of bytes to process).
     */
    public boolean verify(
            Ed25519PublicKey publicKey, byte[] message, int messageOffset, int messageLen) {
        var pubKeyBytes = publicKey.toBytes();
        return Ed25519.verify(sigBytes, 0, pubKeyBytes, 0, message, messageOffset, messageLen);
    }

    /**
     * Get the binary representation of this signature. Can be recovered later with {@link
     * #fromBytes}.
     */
    public byte[] toBytes() {
        return sigBytes.clone();
    }

    /**
     * Get the text representation of this signature. Can be recovered later with {@link
     * #fromString}.
     */
    @Override
    public String toString() {
        return Hex.toHexString(sigBytes);
    }
}
