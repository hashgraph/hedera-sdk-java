package com.hedera.hashgraph.sdk.crypto;

import com.hedera.hashgraph.sdk.Internal;
import com.hedera.hashgraph.sdk.crypto.ed25519.Ed25519PrivateKey;

import org.bouncycastle.crypto.digests.SHA256Digest;
import org.bouncycastle.crypto.digests.SHA512Digest;
import org.bouncycastle.crypto.generators.PKCS5S2ParametersGenerator;
import org.bouncycastle.crypto.params.KeyParameter;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UncheckedIOException;
import java.lang.ref.SoftReference;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

import javax.annotation.Nullable;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * BIP-39 24-word mnemonic phrases compatible with the Android and iOS mobile wallets.
 */
public final class Mnemonic {
    /**
     * The list of words in this mnemonic.
     */
    public final List<CharSequence> words;

    @Nullable
    private String asString;

    boolean isLegacy = false;

    private static final SecureRandom secureRandom = new SecureRandom();

    // by storing our word list in a SoftReference, the GC is free to evict it at its discretion
    // but the implementation is meant to wait until free space is needed
    @Nullable
    private static SoftReference<List<String>> wordList;

    /**
     * Construct a mnemonic from a 24-word list.
     *
     * @param words the 24-word list that constitutes a mnemonic phrase.
     */
    public Mnemonic(List<? extends CharSequence> words) {
        if(words.size() == 22){
            this.isLegacy = true;
        }
        wordList = null;

        this.words = Collections.unmodifiableList(words);
    }

    /**
     * Recover a mnemonic from a string, splitting on spaces.
     */
    public static Mnemonic fromString(String mnemonicString) {
        List<String> list = Arrays.asList(mnemonicString.split(" "));
        Mnemonic mnemonic = new Mnemonic(list);
        wordList = null;

        if(list.size() != 22){
            mnemonic.validate();
        }

        return mnemonic;
    }

    /**
     * @return a new random 24-word mnemonic from the BIP-39 standard English word list.
     */
    public static Mnemonic generate() {
        final byte[] entropy = new byte[32];
        secureRandom.nextBytes(entropy);

        return new Mnemonic(entropyToWords(entropy));
    }

    /**
     * Recover a private key from this mnemonic phrase.
     * <p>
     * This is not compatible with the phrases generated by the Android and iOS wallets;
     * use the no-passphrase version instead.
     *
     * @param passphrase the passphrase used to protect the mnemonic (not used in the
     *                   mobile wallets, use {@link #toPrivateKey()} instead.)
     * @return the recovered key; use {@link Ed25519PrivateKey#derive(int)} to get a key for an
     * account index (0 for default account)
     * @see Ed25519PrivateKey#fromMnemonic(Mnemonic, String)
     */
    public Ed25519PrivateKey toPrivateKey(String passphrase) {
        if(isLegacy){
            throw new Error("This is a legacy mnemonic, please use Mnemonic.toLegacyPrivateKey().");
        }
        return Ed25519PrivateKey.fromMnemonic(this, passphrase);
    }

    public Ed25519PrivateKey toLegacyPrivateKey() {
        if(this.words.size() == 22){
            return Ed25519PrivateKey.fromBytes(this.wordsToLegacyEntropy());
        }

        return Ed25519PrivateKey.fromBytes(this.wordsToLegacyEntropy2());
    }

    /**
     * Recover a private key from this mnemonic phrase.
     *
     * @return the recovered key; use {@link Ed25519PrivateKey#derive(int)} to get a key for an
     * account index (0 for default account)
     * @see Ed25519PrivateKey#fromMnemonic(Mnemonic)
     */
    public Ed25519PrivateKey toPrivateKey() {
        return toPrivateKey("");
    }

    /**
     * Validate that this is a valid BIP-39 mnemonic as generated by BIP-39's rules.
     * <p>
     * Technically, invalid mnemonics can still be used to generate valid private keys,
     * but if they became invalid due to user error then it will be difficult for the user
     * to tell the difference unless they compare the generated keys.
     * <p>
     * During validation, the following conditions are checked in order:
     * <ol>
     *     <li>{@link #words}{@code .length} is exactly 24.</li>
     *     <li>All strings in {@code #words} exist in the BIP-39 standard English word list (no normalization is done).</li>
     *     <li>The calculated checksum for the mnemonic equals the checksum encoded in the mnemonic.</li>
     * </ol>
     * <p>
     * If all of these checks pass, {@link MnemonicValidationResult} is returned with
     * {@link MnemonicValidationResult#status} set to {@link MnemonicValidationStatus#Ok}.
     *
     * @return the result of the validation.
     * @see MnemonicValidationStatus
     * @see <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">
     * Bitcoin Improvement Project proposal 39 (BIP-39)
     * </a>
     * @see <a href="https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt">
     * BIP-39 English word list
     * </a>.
     */

    public MnemonicValidationResult validate() {
        if (this.words.size() != 24) {
            return new MnemonicValidationResult(MnemonicValidationStatus.BadLength);
        }

        ArrayList<Integer> unknownIndices = new ArrayList<>();

        for (int i = 0; i < this.words.size(); i++) {
            if (getWordIndex(this.words.get(i), false) < 0) {
                unknownIndices.add(i);
            }
        }

        if (!unknownIndices.isEmpty()) {
            return new MnemonicValidationResult(MnemonicValidationStatus.UnknownWords, unknownIndices);
        }

        // test the checksum encoded in the mnemonic
        byte[] entropyAndChecksum = wordsToEntropyAndChecksum();
        // ignores the 33rd byte
        byte expectedChecksum = checksum(entropyAndChecksum);
        byte givenChecksum = entropyAndChecksum[32];

        if (givenChecksum != expectedChecksum) {
            return new MnemonicValidationResult(MnemonicValidationStatus.ChecksumMismatch);
        }

        return new MnemonicValidationResult(MnemonicValidationStatus.Ok);
    }



    private byte[] wordsToLegacyEntropy() {
        int[] indices = new int[words.size()];
        for( int i = 0; i < words.size(); i++){
            indices[i] = getWordIndex(words.get(i), true);
        }
        int[] data = convertRadix(indices, 4096, 256, 33);
        int crc = data[ data.length - 1 ];
        int[] result = new int[data.length - 1];
        for (int i = 0; i < data.length - 1; i += 1) {
            result[ i ] = data[ i ] ^ crc;
        }
        //int to byte conversion
        ByteBuffer byteBuffer = ByteBuffer.allocate(result.length * 4);
        IntBuffer intBuffer = byteBuffer.asIntBuffer();
        intBuffer.put(result);

        int crc2 = crc8(result);
        if (crc != crc2) {
            throw new Error("Legacy mnemonic checksum mismatch.");
        }

        byte[] array = byteBuffer.array();
        int i = 0;
        int j = 3;
        byte[] array2 = new byte[data.length-1];
        //remove all the fill 0s
        while(j < array.length){
            array2[i] = array[j];
            i++;
            j = j + 4;
        }

        return array2;
    }

    private byte[] wordsToLegacyEntropy2() {
        int concatBitsLen = this.words.size() * 11;
        boolean[] concatBits = new boolean[concatBitsLen];
        Arrays.fill(concatBits, Boolean.FALSE);

        for (int index = 0; index < this.words.size(); index++) {
            int  nds = Collections.binarySearch(getWordList(false), this.words.get(index), null);

            for(int i = 0; i < 11; i++){
                concatBits[(index * 11) + i] = (nds & (1 << (10 - i))) != 0;
            }
        }

        int checksumBitsLen = concatBitsLen / 33;
        int entropyBitsLen = concatBitsLen - checksumBitsLen;

        byte[] entropy = new byte[entropyBitsLen / 8];

        for (int i = 0; i < entropy.length; i++){
            for (int j = 0; j < 8; j++){
                if(concatBits[(i * 8) + j]){
                    entropy[i] |= 1 << (7 - j);
                }
            }
        }

        SHA256Digest digest = new SHA256Digest();
        byte[] hash = new byte[entropy.length];
        digest.update(entropy, 0, entropy.length);
        digest.doFinal(hash, 0);
        boolean[] hashBits = bytesToBits(hash);

        for (int i = 0; i < checksumBitsLen; i++){
            if (concatBits[entropyBitsLen + i] != hashBits[i]){
                throw new Error("Mnemonic 3 checksum mismatch.");
            }
        }

        return entropy;
    }

    @Override
    public String toString() {
        if (asString == null) {
            asString = String.join(" ", words);
        }

        return asString;
    }

    @Internal
    public byte[] toSeed(String passphrase) {
        final String salt = "mnemonic" + passphrase;

        // BIP-39 seed generation
        final PKCS5S2ParametersGenerator pbkdf2 = new PKCS5S2ParametersGenerator(new SHA512Digest());
        pbkdf2.init(
            toString().getBytes(StandardCharsets.UTF_8),
            salt.getBytes(StandardCharsets.UTF_8),
            2048);

        final KeyParameter key = (KeyParameter) pbkdf2.generateDerivedParameters(512);
        return key.getKey();
    }

    private byte[] wordsToEntropyAndChecksum() {
        if (words.size() != 24) {
            // should be checked in `validate()`
            throw new IllegalStateException(
                "(BUG) expected 24-word mnemonic, got " + words.size() + " words");
        }

        ByteBuffer buffer = ByteBuffer.allocate(33);

        // reverse algorithm of `entropyToWords()` below
        int scratch = 0;
        int offset = 0;
        for (CharSequence word : words) {
            int index = getWordIndex(word, false);

            if (index < 0) {
                // should also be checked in `validate()`
                throw new IllegalStateException("(BUG) word not in word list: " + word);
            } else if (index > 0x7FF) {
                throw new IndexOutOfBoundsException("(BUG) index out of bounds: " + index);
            }

            scratch <<= 11;
            scratch |= index;
            offset += 11;

            while (offset >= 8) {
                // truncation is what we want here
                buffer.put((byte) (scratch >> offset - 8));
                offset -= 8;
            }
        }

        return buffer.array();
    }

    private static List<String> entropyToWords(byte[] entropy) {
        // we only care to support 24 word mnemonics
        if (entropy.length != 32) {
            throw new IllegalArgumentException("invalid entropy byte length: " + entropy.length);
        }

        // checksum for 256 bits is one byte
        byte[] bytes = Arrays.copyOf(entropy, 33);
        bytes[32] = checksum(entropy);

        List<String> wordList = getWordList(false);
        ArrayList<String> words = new ArrayList<>(24);

        int scratch = 0;
        int offset = 0;

        for (byte b : bytes) {
            // shift `bytes` into `scratch`, popping off 11-bit indices when we can
            scratch <<= 8;
            // bitwise operations implicitly widen to `int` so mask off sign-extended bits
            scratch |= b & 0xFF;
            offset += 8;

            if (offset >= 11) {
                // pop 11 bits off the end of `scratch` and into `index`
                int index = (scratch >> offset - 11) & 0x7FF;
                offset -= 11;

                words.add(wordList.get(index));
            }
        }

        return words;
    }

    // hash the first 32 bytes of `entropy` and return the first byte of the digest
    private static byte checksum(byte[] entropy) {
        SHA256Digest digest = new SHA256Digest();
        // hash the first
        digest.update(entropy, 0, 32);

        byte[] checksum = new byte[digest.getDigestSize()];
        digest.doFinal(checksum, 0);

        return checksum[0];
    }

    private static int getWordIndex(CharSequence word, boolean isLegacy) {
        return Collections.binarySearch(getWordList(isLegacy), word, null);
    }

    private static List<String> getWordList(boolean isLegacy) {
        if (wordList == null || wordList.get() == null) {
            synchronized (Mnemonic.class) {
                if (wordList == null || wordList.get() == null) {
                    List<String> words = readWordList(isLegacy);
                    wordList = new SoftReference<>(words);
                    // immediately return the strong reference
                    return words;
                }
            }
        }

        return wordList.get();
    }

    private static List<String> readWordList(boolean isLegacy) {
        if(isLegacy){
            InputStream wordStream = Mnemonic.class.getClassLoader().getResourceAsStream("legacy-english.txt");
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(Objects.requireNonNull(wordStream), UTF_8))) {
                ArrayList<String> words = new ArrayList<>(4096);

                for (String word = reader.readLine(); word != null; word = reader.readLine()) {
                    words.add(word);
                }
                return Collections.unmodifiableList(words);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }
        else{
            InputStream wordStream = Mnemonic.class.getClassLoader().getResourceAsStream("bip39-english.txt");
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(Objects.requireNonNull(wordStream)))) {
                ArrayList<String> words = new ArrayList<>(2048);

                for (String word = reader.readLine(); word != null; word = reader.readLine()) {
                    words.add(word);
                }
                return Collections.unmodifiableList(words);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }
    }

    private static int[] convertRadix(int[] nums, int fromRadix, int toRadix,int toLength){
        BigInteger num = BigInteger.valueOf(0);
        for (int element : nums) {
            num = num.multiply(BigInteger.valueOf(fromRadix));
            num = num.add(BigInteger.valueOf(element));
        }

        int[] result = new int[toLength];
        for (int i = toLength - 1; i >= 0; i -= 1) {
            BigInteger tem = num.divide(BigInteger.valueOf(toRadix));
            BigInteger rem = num.mod(BigInteger.valueOf(toRadix));
            num = tem;
            result[ i ] = rem.intValue();
        }

        return result;
    }

    private static int crc8(int[] data) {
        int crc = 0xFF;

        for (int i = 0; i < data.length - 1; i += 1) {
            crc ^= data[ i ];
            for (int j = 0; j < 8; j += 1) {
                crc = (crc >>> 1) ^ (((crc & 1) == 0) ? 0 : 0xB2);
            }
        }

        return crc ^ 0xFF;
    }

    private static boolean[] bytesToBits(byte[] dat){
        boolean[] bits = new boolean[dat.length * 8];
        Arrays.fill(bits, Boolean.FALSE);

        for (int i = 0; i < dat.length; i ++){
            for (int j = 0; j < 8; j++){
                bits[(i * 8) + j] = (dat[i] & (1 << (7 - j))) != 0;
            }
        }

        return bits;
    }
}
